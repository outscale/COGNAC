/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "json.h"
#include "osc_sdk.h"
#include "main-helper.h"

#ifndef JSON_C_TO_STRING_COLOR
#define JSON_C_TO_STRING_COLOR 0
#endif

#define OAPI_RAW_OUTPUT 1

#define OAPI_CLI_VERSION "____cli_version____"

#define OAPI_CLI_UAGENT "oapi-cli/"OAPI_CLI_VERSION"; osc-sdk-c/"

#define STRY(f, args...)					\
	do {							\
		if (f) {return 1;}				\
	} while(0)

#define TRY(f, args...)						\
	do {							\
		if (f) {fprintf(stderr, args);  return -1;}	\
	} while(0)


#define VAR_NAME_SIZE 128
#define VAR_VAL_SIZE 512
#define VAR_ARRAY_SIZE 128

static int nb_cli_vars;

struct cli_var {
	char name[VAR_NAME_SIZE];
	char val[VAR_VAL_SIZE];
} cli_vars[VAR_ARRAY_SIZE];

static void *cascade_struct;
static int (*cascade_parser)(void *, char *, char *, struct ptr_array *);

static int argcmp2(const char *s1, const char *s2, char dst)
{
	while (*s1 == *s2 && *s1 && *s2) {
		s1++;
		s2++;
	}
	if ((*s2 == dst && *s1 == '\0') ||
	    (*s1 == dst && *s2 == '\0'))
		return 0;
	return *s1 - *s2;
}

static int argcmp(const char *s1, const char *s2)
{
	return argcmp2(s1, s2, '.');
}

#define MAX_FILES_PER_CMD 64

static void files_cnt_cleanup(char * (*files_cnt_ptr)[64])
{
	for (int i = 0; i < MAX_FILES_PER_CMD && (*files_cnt_ptr)[i]; ++i) {
		free((*files_cnt_ptr)[i]);
	}
}

char *string_to_jsonstr(char **file_str_p)
{
	/* no auto free, as we steal s.buf */
	struct osc_str s;
	char *in = *file_str_p;
	char *double_quote;
	char *tmp = in;

	osc_init_str(&s);
	while((double_quote = strchr(tmp, '"')) != NULL) {
		int l = double_quote - tmp;

		osc_str_append_n_string(&s, tmp, l);
		osc_str_append_string(&s, "\\\"");
		tmp = double_quote + 1;
	}
	osc_str_append_string(&s, tmp);

	free(in);
	*file_str_p = s.buf;
	return *file_str_p;
}

static int parse_variable(json_object *jobj, char **av, int ac, int i)
{
	const char *tmp = av[i + 1];
	const char *tmp2;
	TRY(nb_cli_vars >= VAR_ARRAY_SIZE, "variable asignement fail: too much variables");
	struct cli_var *var = &cli_vars[nb_cli_vars++];
	json_object *j = jobj;
	char buf[512];

	tmp2 = strchr(tmp, '=');
	TRY(!tmp2, "variable asignement fail (missing '='))\n");
	TRY((uintptr_t)(tmp2 - tmp) >= VAR_NAME_SIZE, "var name too long");
	strncpy(var->name, tmp, tmp2 - tmp);
	var->name[tmp2 - tmp] = 0;
	tmp = tmp2 + 1;

	while ((tmp2 = strchr(tmp, '.')) != NULL) {
		char *end = NULL;
		// get json
		int idx = strtoul(tmp, &end, 0);
		if (end != tmp) {
			j = json_object_array_get_idx(j, idx);
		} else {
			TRY((uintptr_t)(tmp2 - tmp) >= sizeof buf - 1,
			    "variable asignement fail");
			strncpy(buf, tmp, tmp2 - tmp);
			buf[tmp2 - tmp] = 0;
			j = json_object_object_get(j, buf);
		}
		TRY(!j, "variable asignement fail (not found)");
		tmp = tmp2 + 1;
	}
	tmp2 = tmp + strlen(tmp);
	TRY((uintptr_t)(tmp2 - tmp) >= sizeof buf - 1,
	    "variable asignement fail");
	strncpy(buf, tmp, tmp2 - tmp);
	buf[tmp2 - tmp] = 0;
	j = json_object_object_get(j, buf);
	if (json_object_is_type(j, json_type_string)) {
		tmp = json_object_get_string(j);
	} else {
		tmp = json_object_to_json_string_ext(j, JSON_C_TO_STRING_PLAIN);
	}
	TRY(strlen(tmp) >= VAR_VAL_SIZE, "variable asignement fail: value too big");
	strcpy(var->val, tmp);
	return 0;

}

char *read_file(char *files_cnt[static MAX_FILES_PER_CMD], char *file_name,
		int is_json)
{
	int dest = -1;
	const char *call_name = is_json ? "--jsonstr-file" : "--file";
	for (int i = 0; i < MAX_FILES_PER_CMD; ++i) {
		if (!files_cnt[i]) {
			dest = i;
			break;
		}
	}
	if (dest < 0) {
		fprintf(stderr, "%s option used too much", call_name);
		return NULL;
	}
	FILE *f = fopen(file_name, "rb");
	if (!f) {
		fprintf(stderr, "%s fail to open %s", call_name, file_name);
		return NULL;
	}
	if (fseek(f, 0, SEEK_END) < 0) {
		fprintf(stderr, "%s fseek fail for %s", call_name, file_name);
		goto error;
	}
	long fsize = ftell(f);
	if (fseek(f, 0, SEEK_SET) < 0) {
		fprintf(stderr, "%s fseek fail for %s", call_name, file_name);
		goto error;
	}

	files_cnt[dest] = malloc(fsize + 1);
	if (!files_cnt[dest]) {
		fprintf(stderr, "%s malloc fail for %s", call_name, file_name);
		goto error;
	}
	fread(files_cnt[dest], fsize, 1, f);
	if (ferror(f)) {
		fprintf(stderr, "%s fread fail for %s", call_name, file_name);
		goto error;
	}
	fclose(f);
	files_cnt[dest][fsize] = 0;
	if (is_json)
		return string_to_jsonstr(&files_cnt[dest]);
	return files_cnt[dest];
error:
	fclose(f);
	return NULL;
}

____complex_struct_func_parser____


static int str_auth_method_to_int(const char *str)
{
	if (!strcmp(str, "password") || !strcmp(str, "basic"))
		return OSC_PASSWORD_METHOD;
	else if (!strcmp(str, "none"))
		return OSC_NONE_METHOD;
	else if (!strcmp(str, "accesskey"))
		return OSC_AKSK_METHOD;
	return -1;
}

int main(int ac, char **av)
{
	auto_osc_env struct osc_env e = {0};
	auto_osc_str struct osc_str r = {0};
	int color_flag = 0;
	int i;
	char *help_appent = getenv("COGNAC_HELP_APPEND");
	unsigned int flag = 0;
	unsigned int program_flag = 0;
	char *program_name = strrchr(av[0], '/');
	char *profile = NULL;
	char *login = NULL;
	char *password = NULL;
	int auth_m = OSC_AKSK_METHOD;
	int ret = 1;

	if (!program_name)
		program_name = av[0];
	else
		++program_name;

	for (i = 1; i < ac; ++i) {
		if (!strcmp("--verbose", av[i])) {
		  flag |= OSC_VERBOSE_MODE;
		} else if (!strcmp("--insecure", av[i])) {
		  flag |= OSC_INSECURE_MODE;
		} else if (!strcmp("--version", av[i])) {
			printf("oapi-cli version: %s\n"
			       "osc-sdk-c version: %s\n"
			       "based on osc-api: %s\n",
			       OAPI_CLI_VERSION,
			       osc_sdk_version_str(),
			       OSC_API_VERSION);
			return 0;
		} else if (!strcmp("--raw-print", av[i])) {
		  program_flag |= OAPI_RAW_OUTPUT;
		} else if (!strcmp("--list-calls", av[i])) {
			const char **names = osc_calls_name();

			for (const char **n = names; *n; ++n) {
				printf("%s\n", *n);
			}
			return 0;
		} else if (!strcmp("--help", av[i]) || !strcmp("-h", av[i])) {
		  auth_m = OSC_NONE_METHOD;
		} else if (!argcmp2("--auth-method", av[i], '=')) {
			const char *auth_str;
			if (av[i][sizeof("--auth-method") - 1] == '=') {
				auth_str = &av[i][sizeof("--auth-method")];
			} else if (!av[i][sizeof("--auth-method") - 1]) {
				TRY(!av[i+1], "-- need an auth-method\n");
				auth_str = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--auth-method seems weirds\n");
				return 1;
			}
			auth_m = str_auth_method_to_int(auth_str);
			TRY(auth_m < 0, "%s unknown auth-method\n", auth_str);
		} else if (!argcmp2("--authentication_method", av[i], '=')) {
			const char *auth_str;
			if (av[i][sizeof("--authentication_method") - 1] == '=') {
				auth_str = &av[i][sizeof("--authentication_method")];
			} else if (!av[i][sizeof("--authentication_method") - 1]) {
				TRY(!av[i+1], "-- need an authentication_method\n");
				auth_str = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--authentication_method seems weirds\n");
				return 1;
			}
			auth_m = str_auth_method_to_int(auth_str);
			TRY(auth_m < 0, "%s unknown authentication_method\n", auth_str);
		} else if (!argcmp2("--config", av[i], '=')) {
			const char *cfg_str;
			if (av[i][sizeof("--config") - 1] == '=') {
				cfg_str = &av[i][sizeof("--config")];
			} else if (!av[i][sizeof("--config") - 1]) {
				TRY(!av[i+1], "--config need a path\n");
				cfg_str = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--config seems weirds\n");
				return 1;
			}
			osc_set_cfg_path(cfg_str);
		} else if (!argcmp2("--profile", av[i], '=')) {
			if (av[i][sizeof("--profile") - 1] == '=') {
				profile = &av[i][sizeof("--profile")];
			} else if (!av[i][sizeof("--profile") - 1]) {
				TRY(!av[i+1], "--profile need a profile");
				profile = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--profile seems weirds");
				return 1;
			}
		} else if (!argcmp2("--password", av[i], '=')) {
			if (av[i][sizeof("--password") - 1] == '=') {
				password = &av[i][sizeof("--password")];
			} else if (!av[i][sizeof("--password") - 1]) {
				TRY(!av[i+1], "--password need a password");
				password = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--password seems weirds");
				return 1;
			}
		} else if (!argcmp2("--login", av[i], '=')) {
			if (av[i][sizeof("--login") - 1] == '=') {
				login = &av[i][sizeof("--login")];
			} else if (!av[i][sizeof("--login") - 1]) {
				TRY(!av[i+1], "--login need a login");
				login = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--login seems weirds");
				return 1;
			}
		}
	}

	if (login || password)
		auth_m = OSC_PASSWORD_METHOD;

	if (ac < 2 || (ac == 2 && !strcmp(av[1], "--help"))) {
	show_help:
                printf("Usage: %s [--help] CallName [options] [--Params <param_argument | [--file | --jsonstr-file] <file_name>>] | --var <variable_name>\n"
                       "options:\n"
                       "\t    --auth-method=METHODE set authentification method, password|accesskey|none\n"
                       "\t    --color               try to colorize json if json-c support it\n"
                       "\t    --config=PATH         config file path\n"
		       "\t    --file PATH           use content of PATH as an agrument for a call, example:\n"
		       "\t\t\t\toapi-cli CreateCa  --CaPem --file /$CA_DIR/cert.pem\n"
		       "\t    --jsonstr-file PATH   same as --file, except the content is surrounded by \"\n"
		       "\t\t\t\tand \" inside the file are escape with a \\, this option is useful for CreatePolicy\n"
		       "\t    --set-var ID=VARIABLE_PATH  Create an oapi-cli variable, that can be use with --var\n"
		       "\t\t\t\tExamples: ./oapi-cli ReadVms --Filters.TagValues[] VM_NAME --set-var id=Vms.0.VmId ReadVms --Filters.VmIds[] --var id\n"
		       "\t\t\t\twill find the vm with VM_NAME as it's tag, and read it again, but using it's VmId as filter this time\n"
		       "\t    --var                 use variabble content created by --set-var\n"
                       "\t-h, --help [CallName]     this, can be used with call name, example:\n\t\t\t\t%s --help ReadVms\n"
                       "\t    --list-calls          list all calls\n"
                       "\t    --insecure            doesn't verify SSL certificats\n"
                       "\t    --login=EMAIL         set email, and authentification as password\n"
                       "\t    --password=PASS       set password, and authentification as password\n"
                       "\t    --profile=PROFILE     select profile\n"
                       "\t    --raw-print           doesn't format the output\n"
                       "\t    --verbose             curl backend is now verbose\n"
                       "\t    --version             oapi-cli version info\n%s%s",
		       program_name, program_name, help_appent ? help_appent : "",
		       help_appent ? "\n" : "");
		return 0;
	}

	TRY(osc_init_sdk_ext(&e, profile, flag,
			     &(struct osc_env_conf){
				     .auth_method=auth_m,
				     .password=password,
				     .login=login
			     }),
	    "fail to init C sdk\n");
	osc_init_str(&r);

	char user_agent[OSC_SDK_VERSON_L + sizeof OAPI_CLI_UAGENT] =
		OAPI_CLI_UAGENT;

	strcpy(user_agent + sizeof OAPI_CLI_UAGENT - 1, osc_sdk_version_str());
	osc_sdk_set_useragent(&e, user_agent);

	for (i = 1; i < ac; ++i) {
		if (!strcmp("--verbose", av[i]) ||		\
		    !strcmp("--insecure", av[i]) ||		\
		    !strcmp("--raw-print", av[i])) {
			/* Avoid Unknown Calls */
		} else if (!argcmp2("--profile", av[i], '=')) {
			if (!av[i][sizeof("--profile") - 1]) {
				++i;
			}
		} else if (!argcmp2("--auth-method", av[i], '=')) {
			if (!av[i][sizeof("--auth-method") - 1]) {
				++i;
			}
		} else if (!argcmp2("--authentication_method", av[i], '=')) {
			if (!av[i][sizeof("--authentication_method") - 1]) {
				++i;
			}
		} else if (!argcmp2("--config", av[i], '=')) {
			if (!av[i][sizeof("--config") - 1]) {
				++i;
			}
		} else if (!argcmp2("--password", av[i], '=')) {
			if (!av[i][sizeof("--password") - 1]) {
				++i;
			}
		} else if (!argcmp2("--login", av[i], '=')) {
			if (!av[i][sizeof("--login") - 1]) {
				++i;
			}
		} else if (!strcmp("--help", av[i]) || !strcmp("-h", av[i])) {
			if (av[i+1]) {
				const char *cd = osc_find_description(av[i+1]);
				const char *cad = osc_find_args_description(av[i+1]);
				if (cd) {
					puts(cd);
					puts("Arguments Description:");
					puts(cad);
					goto good;
				} else {
					printf("Unknown Call %s\n", av[i+1]);
					goto out;
				}
			}
			goto show_help;
		} else if (!strcmp("--color", av[i])) {
			color_flag |= JSON_C_TO_STRING_COLOR;
		} else
		____cli_parser____
		{
			printf("Unknown Call %s\n", av[i]);
			ret = 1;
			goto out;
		}
	}
good:
	ret = 0;
out:
	return ret;
}
